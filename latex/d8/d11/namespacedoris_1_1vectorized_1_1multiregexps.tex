\hypertarget{namespacedoris_1_1vectorized_1_1multiregexps}{}\doxysection{doris\+::vectorized\+::multiregexps 命名空间参考}
\label{namespacedoris_1_1vectorized_1_1multiregexps}\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classdoris_1_1vectorized_1_1multiregexps_1_1_deferred_constructed_regexps}{Deferred\+Constructed\+Regexps}}
\item 
struct \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_global_cache_table}{Global\+Cache\+Table}}
\item 
struct \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}
\item 
class \mbox{\hyperlink{classdoris_1_1vectorized_1_1multiregexps_1_1_regexps}{Regexps}}
\begin{DoxyCompactList}\small\item\em Database is thread safe across multiple threads and Scratch is not but we can copy it whenever we use it in the searcher. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{类型定义}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a75303ec454ffb6a5909762b85e3172f3}{Compiler\+Error}} = std\+::unique\+\_\+ptr$<$ hs\+\_\+compile\+\_\+error\+\_\+t, \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}$<$ decltype(\&hs\+\_\+free\+\_\+compile\+\_\+error), \&hs\+\_\+free\+\_\+compile\+\_\+error $>$ $>$
\begin{DoxyCompactList}\small\item\em Helper unique pointers to correctly delete the allocated space when hyperscan cannot compile something and we throw an exception. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a38c09bab5b7729494e7d53b9d1f1e210}{Scratch\+Ptr}} = std\+::unique\+\_\+ptr$<$ hs\+\_\+scratch\+\_\+t, \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}$<$ decltype(\&hs\+\_\+free\+\_\+scratch), \&hs\+\_\+free\+\_\+scratch $>$ $>$
\item 
using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a1a0c43fb5454a62237c562c69580d386}{Data\+Base\+Ptr}} = std\+::unique\+\_\+ptr$<$ hs\+\_\+database\+\_\+t, \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}$<$ decltype(\&hs\+\_\+free\+\_\+database), \&hs\+\_\+free\+\_\+database $>$ $>$
\item 
using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_af16260e02b86d819e4e65d39a54c566e}{Deferred\+Constructed\+Regexps\+Ptr}} = std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classdoris_1_1vectorized_1_1multiregexps_1_1_deferred_constructed_regexps}{Deferred\+Constructed\+Regexps}} $>$
\end{DoxyCompactItemize}
\doxysubsection*{函数}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$bool save\+\_\+indices, bool With\+Edit\+Distance$>$ }\\\mbox{\hyperlink{classdoris_1_1vectorized_1_1multiregexps_1_1_regexps}{Regexps}} \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a41158d2c25d3e43f2571731fa6836842}{construct\+Regexps}} (const std\+::vector$<$ \mbox{\hyperlink{namespacedoris_1_1vectorized_a5573b97b9e5129f61d289e037d7e806c}{String}} $>$ \&str\+\_\+patterns, std\+::optional$<$ \mbox{\hyperlink{namespacedoris_1_1vectorized_a16bda7e33183fb876dbb944cbb556702}{UInt32}} $>$ edit\+\_\+distance)
\item 
{\footnotesize template$<$bool save\+\_\+indices, bool With\+Edit\+Distance$>$ }\\\mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_af16260e02b86d819e4e65d39a54c566e}{Deferred\+Constructed\+Regexps\+Ptr}} \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a58a2fd0216c72d66bd96c245d1086926}{get\+Or\+Set}} (const std\+::vector$<$ \mbox{\hyperlink{structdoris_1_1_string_ref}{String\+Ref}} $>$ \&patterns, std\+::optional$<$ \mbox{\hyperlink{namespacedoris_1_1vectorized_a16bda7e33183fb876dbb944cbb556702}{UInt32}} $>$ edit\+\_\+distance)
\end{DoxyCompactItemize}


\doxysubsection{类型定义说明}
\mbox{\Hypertarget{namespacedoris_1_1vectorized_1_1multiregexps_a75303ec454ffb6a5909762b85e3172f3}\label{namespacedoris_1_1vectorized_1_1multiregexps_a75303ec454ffb6a5909762b85e3172f3}} 
\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}!CompilerError@{CompilerError}}
\index{CompilerError@{CompilerError}!doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsubsection{\texorpdfstring{CompilerError}{CompilerError}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a75303ec454ffb6a5909762b85e3172f3}{Compiler\+Error}} =  std\+::unique\+\_\+ptr$<$hs\+\_\+compile\+\_\+error\+\_\+t, \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}$<$decltype(\&hs\+\_\+free\+\_\+compile\+\_\+error), \&hs\+\_\+free\+\_\+compile\+\_\+error$>$ $>$}



Helper unique pointers to correctly delete the allocated space when hyperscan cannot compile something and we throw an exception. 

\mbox{\Hypertarget{namespacedoris_1_1vectorized_1_1multiregexps_a38c09bab5b7729494e7d53b9d1f1e210}\label{namespacedoris_1_1vectorized_1_1multiregexps_a38c09bab5b7729494e7d53b9d1f1e210}} 
\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}!ScratchPtr@{ScratchPtr}}
\index{ScratchPtr@{ScratchPtr}!doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsubsection{\texorpdfstring{ScratchPtr}{ScratchPtr}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a38c09bab5b7729494e7d53b9d1f1e210}{Scratch\+Ptr}} =  std\+::unique\+\_\+ptr$<$hs\+\_\+scratch\+\_\+t, \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}$<$decltype(\&hs\+\_\+free\+\_\+scratch), \&hs\+\_\+free\+\_\+scratch$>$ $>$}

\mbox{\Hypertarget{namespacedoris_1_1vectorized_1_1multiregexps_a1a0c43fb5454a62237c562c69580d386}\label{namespacedoris_1_1vectorized_1_1multiregexps_a1a0c43fb5454a62237c562c69580d386}} 
\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}!DataBasePtr@{DataBasePtr}}
\index{DataBasePtr@{DataBasePtr}!doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsubsection{\texorpdfstring{DataBasePtr}{DataBasePtr}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_a1a0c43fb5454a62237c562c69580d386}{Data\+Base\+Ptr}} =  std\+::unique\+\_\+ptr$<$hs\+\_\+database\+\_\+t, \mbox{\hyperlink{structdoris_1_1vectorized_1_1multiregexps_1_1_hyperscan_deleter}{Hyperscan\+Deleter}}$<$decltype(\&hs\+\_\+free\+\_\+database), \&hs\+\_\+free\+\_\+database$>$ $>$}

\mbox{\Hypertarget{namespacedoris_1_1vectorized_1_1multiregexps_af16260e02b86d819e4e65d39a54c566e}\label{namespacedoris_1_1vectorized_1_1multiregexps_af16260e02b86d819e4e65d39a54c566e}} 
\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}!DeferredConstructedRegexpsPtr@{DeferredConstructedRegexpsPtr}}
\index{DeferredConstructedRegexpsPtr@{DeferredConstructedRegexpsPtr}!doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsubsection{\texorpdfstring{DeferredConstructedRegexpsPtr}{DeferredConstructedRegexpsPtr}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_af16260e02b86d819e4e65d39a54c566e}{Deferred\+Constructed\+Regexps\+Ptr}} =  std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{classdoris_1_1vectorized_1_1multiregexps_1_1_deferred_constructed_regexps}{Deferred\+Constructed\+Regexps}}$>$}



\doxysubsection{函数说明}
\mbox{\Hypertarget{namespacedoris_1_1vectorized_1_1multiregexps_a41158d2c25d3e43f2571731fa6836842}\label{namespacedoris_1_1vectorized_1_1multiregexps_a41158d2c25d3e43f2571731fa6836842}} 
\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}!constructRegexps@{constructRegexps}}
\index{constructRegexps@{constructRegexps}!doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsubsection{\texorpdfstring{constructRegexps()}{constructRegexps()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1vectorized_1_1multiregexps_1_1_regexps}{Regexps}} construct\+Regexps (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{namespacedoris_1_1vectorized_a5573b97b9e5129f61d289e037d7e806c}{String}} $>$ \&}]{str\+\_\+patterns,  }\item[{std\+::optional$<$ \mbox{\hyperlink{namespacedoris_1_1vectorized_a16bda7e33183fb876dbb944cbb556702}{UInt32}} $>$}]{edit\+\_\+distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Common pointers

Pointer for external edit distance compilation

Hyperscan currently does not support UTF8 matching with edit distance.

HS\+\_\+\+EXT\+\_\+\+FLAG\+\_\+\+EDIT\+\_\+\+DISTANCE is a compile flag responsible for Levenstein distance.

We mark the patterns to provide the callback results.

Compiler\+Error is a unique\+\_\+ptr, so correct memory free after the exception is thrown.

We allocate the scratch space only once, then copy it across multiple threads with hs\+\_\+clone\+\_\+scratch function which is faster than allocating scratch space each time in each thread.

If not HS\+\_\+\+SUCCESS, it is guaranteed that the memory would not be allocated for scratch.\mbox{\Hypertarget{namespacedoris_1_1vectorized_1_1multiregexps_a58a2fd0216c72d66bd96c245d1086926}\label{namespacedoris_1_1vectorized_1_1multiregexps_a58a2fd0216c72d66bd96c245d1086926}} 
\index{doris::vectorized::multiregexps@{doris::vectorized::multiregexps}!getOrSet@{getOrSet}}
\index{getOrSet@{getOrSet}!doris::vectorized::multiregexps@{doris::vectorized::multiregexps}}
\doxysubsubsection{\texorpdfstring{getOrSet()}{getOrSet()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacedoris_1_1vectorized_1_1multiregexps_af16260e02b86d819e4e65d39a54c566e}{Deferred\+Constructed\+Regexps\+Ptr}} get\+Or\+Set (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{structdoris_1_1_string_ref}{String\+Ref}} $>$ \&}]{patterns,  }\item[{std\+::optional$<$ \mbox{\hyperlink{namespacedoris_1_1vectorized_a16bda7e33183fb876dbb944cbb556702}{UInt32}} $>$}]{edit\+\_\+distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

If With\+Edit\+Distance is False, edit\+\_\+distance must be nullopt. Also, we use templates here because each instantiation of function template has its own copy of local static variables which must not be the same for different hyperscan compilations. Different variables for different pattern parameters, thread-\/safe in C++11

Lock cache to find compiled regexp for given pattern vector + edit distance.

Pattern compilation is expensive and we don\textquotesingle{}t want to block other threads reading from / inserting into the cache while we hold the cache lock during pattern compilation. Therefore, when a cache entry is created or replaced, only set the regexp constructor method and compile outside the cache lock. Note that the string patterns and the edit distance is passed into the constructor lambda by value, i.\+e. copied -\/ it is not an option to reference the corresponding string patterns / edit distance key in the cache table bucket because the cache entry may already be evicted at the time the compilation starts.

insert new entry

replace existing entry函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{d8/d11/namespacedoris_1_1vectorized_1_1multiregexps_a58a2fd0216c72d66bd96c245d1086926_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{d8/d11/namespacedoris_1_1vectorized_1_1multiregexps_a58a2fd0216c72d66bd96c245d1086926_icgraph}
\end{center}
\end{figure}
