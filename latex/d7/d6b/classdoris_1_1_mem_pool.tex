\hypertarget{classdoris_1_1_mem_pool}{}\doxysection{Mem\+Pool类 参考}
\label{classdoris_1_1_mem_pool}\index{MemPool@{MemPool}}


{\ttfamily \#include $<$mem\+\_\+pool.\+h$>$}



Mem\+Pool 的协作图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=182pt]{da/d22/classdoris_1_1_mem_pool__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{类}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structdoris_1_1_mem_pool_1_1_chunk_info}{Chunk\+Info}}
\end{DoxyCompactItemize}
\doxysubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classdoris_1_1_mem_pool_a8b3cced6f5cb7c5084768b29bb461a00}{Mem\+Pool}} (\mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}} $\ast$\mbox{\hyperlink{classdoris_1_1_mem_pool_a3784f1d2cedbd86999122cf6b1419e81}{mem\+\_\+tracker}})
\item 
\mbox{\hyperlink{classdoris_1_1_mem_pool_a42145941c12bbb94e798490e14f940f4}{Mem\+Pool}} ()
\item 
\mbox{\hyperlink{classdoris_1_1_mem_pool_a5d9436e563027071fb7f5471f26af32c}{$\sim$\+Mem\+Pool}} ()
\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a6bbe6a57173c878bdb87ee90c87022a9}{allocate}} (int64\+\_\+t size, bool free\+\_\+old\+\_\+chunks=false)
\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_ae6c8a9fd44a082f7172774fa2592c89b}{allocate\+\_\+aligned}} (int64\+\_\+t size, int alignment)
\item 
\mbox{\hyperlink{classdoris_1_1_status}{Status}} \mbox{\hyperlink{classdoris_1_1_mem_pool_a09fa199573f5b5e14ccbf12b75d7dc1c}{allocate\+\_\+safely}} (int64\+\_\+t size, uint8\+\_\+t $\ast$\&\mbox{\hyperlink{doris__main_8cpp_ab07b31d4e8924e322ffed3f51d39e425}{ret}})
\begin{DoxyCompactList}\small\item\em Same as Allocate() expect add a check when return a nullptr \end{DoxyCompactList}\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a77c864da08b18a7f329ea3a4f03d3a49}{try\+\_\+allocate}} (int64\+\_\+t size)
\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a593527fbb6f92934decc5c9971e6a6ed}{try\+\_\+allocate\+\_\+aligned}} (int64\+\_\+t size, int alignment)
\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a6d26bcac68a4840a8aed98fe68998980}{try\+\_\+allocate\+\_\+unaligned}} (int64\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Same as Try\+Allocate() except returned memory is not aligned at all. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classdoris_1_1_mem_pool_ac8bb3912a3ce86b15842e79d0b421204}{clear}} ()
\begin{DoxyCompactList}\small\item\em Makes all allocated chunks available for re-\/use, but doesn\textquotesingle{}t delete any chunks. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classdoris_1_1_mem_pool_af4de2f83436cd4ed6744ced00335545a}{free\+\_\+all}} ()
\item 
void \mbox{\hyperlink{classdoris_1_1_mem_pool_a8390fe0aaec400317015c6c6f4c885b2}{acquire\+\_\+data}} (\mbox{\hyperlink{classdoris_1_1_mem_pool}{Mem\+Pool}} $\ast$src, bool keep\+\_\+current)
\item 
std\+::string \mbox{\hyperlink{classdoris_1_1_mem_pool_a4dcb28d0641b6d37aef23c662ec11908}{debug\+\_\+string}} ()
\item 
int64\+\_\+t \mbox{\hyperlink{classdoris_1_1_mem_pool_ac2c82d6ddaca81b4a1fbea56357a56a0}{total\+\_\+allocated\+\_\+bytes}} () const
\item 
int64\+\_\+t \mbox{\hyperlink{classdoris_1_1_mem_pool_aa18c7f597cda80b68976807afee3ccae}{total\+\_\+reserved\+\_\+bytes}} () const
\item 
\mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}} $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a3784f1d2cedbd86999122cf6b1419e81}{mem\+\_\+tracker}} ()
\end{DoxyCompactItemize}
\doxysubsection*{静态 Public 属性}
\begin{DoxyCompactItemize}
\item 
static constexpr int \mbox{\hyperlink{classdoris_1_1_mem_pool_a55e30d64539971321c58aa1a26d8b671}{DEFAULT\+\_\+\+ALIGNMENT}} = 16
\item 
static constexpr int \mbox{\hyperlink{classdoris_1_1_mem_pool_a23ec6fd4aacd7be3f89a40feab9b4539}{DEFAULT\+\_\+\+PADDING\+\_\+\+SIZE}} = 0x0
\end{DoxyCompactItemize}
\doxysubsection*{Private 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classdoris_1_1_status}{Status}} \mbox{\hyperlink{classdoris_1_1_mem_pool_a496b30429df7da46fc8fdc8cd6ffa680}{find\+\_\+chunk}} (size\+\_\+t min\+\_\+size, bool check\+\_\+limits, bool free\+\_\+old\+\_\+chunks)
\item 
bool \mbox{\hyperlink{classdoris_1_1_mem_pool_a6b20ce905b38d4fdd3d623e2d1fad9b2}{check\+\_\+integrity}} (bool check\+\_\+current\+\_\+chunk\+\_\+empty)
\item 
int64\+\_\+t \mbox{\hyperlink{classdoris_1_1_mem_pool_a3c2ed43ca91dcc971913c2a307df6d77}{get\+\_\+free\+\_\+offset}} () const
\begin{DoxyCompactList}\small\item\em Return offset to unoccupied space in current chunk. \end{DoxyCompactList}\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a55575a1816c844dbbaf0dba2cd0af4c0}{allocate\+\_\+from\+\_\+current\+\_\+chunk}} (int64\+\_\+t size, int alignment)
\item 
{\footnotesize template$<$bool CHECK\+\_\+\+LIMIT\+\_\+\+FIRST$>$ }\\uint8\+\_\+t $\ast$\mbox{\hyperlink{compiler__util_8h_aa1dec568e79152c892dcf63f445cbd7a}{ALWAYS\+\_\+\+INLINE}} \mbox{\hyperlink{classdoris_1_1_mem_pool_abcb9972328c7f8747a778c0969829d1a}{allocate}} (int64\+\_\+t size, int alignment, bool free\+\_\+old\+\_\+chunks=false)
\item 
{\footnotesize template$<$bool CHECK\+\_\+\+LIMIT\+\_\+\+FIRST$>$ }\\\mbox{\hyperlink{classdoris_1_1_status}{Status}} \mbox{\hyperlink{compiler__util_8h_aa1dec568e79152c892dcf63f445cbd7a}{ALWAYS\+\_\+\+INLINE}} \mbox{\hyperlink{classdoris_1_1_mem_pool_a742414fe4ed173877a599b5b44c509c5}{allocate\+\_\+safely}} (int64\+\_\+t size, int alignment, uint8\+\_\+t $\ast$\&\mbox{\hyperlink{doris__main_8cpp_ab07b31d4e8924e322ffed3f51d39e425}{ret}})
\end{DoxyCompactItemize}
\doxysubsection*{Private 属性}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classdoris_1_1_mem_pool_aed7d68711317ab1df2c91ff520320321}{current\+\_\+chunk\+\_\+idx\+\_\+}}
\item 
int \mbox{\hyperlink{classdoris_1_1_mem_pool_a960c7e4aa89884aae5bc4ba96cc74167}{next\+\_\+chunk\+\_\+size\+\_\+}}
\begin{DoxyCompactList}\small\item\em The size of the next chunk to allocate. \end{DoxyCompactList}\item 
int64\+\_\+t \mbox{\hyperlink{classdoris_1_1_mem_pool_a5999667e31d6e6cd3dfbae837e52d2f1}{total\+\_\+allocated\+\_\+bytes\+\_\+}}
\begin{DoxyCompactList}\small\item\em sum of allocated\+\_\+bytes\+\_\+ \end{DoxyCompactList}\item 
int64\+\_\+t \mbox{\hyperlink{classdoris_1_1_mem_pool_a8207c0d5e43fdd326d0064ea5f5a76d7}{total\+\_\+reserved\+\_\+bytes\+\_\+}}
\begin{DoxyCompactList}\small\item\em sum of all bytes allocated in chunks\+\_\+ \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{structdoris_1_1_mem_pool_1_1_chunk_info}{Chunk\+Info}} $>$ \mbox{\hyperlink{classdoris_1_1_mem_pool_a481f648c78e8f8ac2912c950c0f34e6c}{chunks\+\_\+}}
\item 
\mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}} $\ast$ \mbox{\hyperlink{classdoris_1_1_mem_pool_aeb56efb11f09c22f1a97a0238206da30}{\+\_\+mem\+\_\+tracker}}
\end{DoxyCompactItemize}
\doxysubsection*{静态 Private 属性}
\begin{DoxyCompactItemize}
\item 
static const int \mbox{\hyperlink{classdoris_1_1_mem_pool_a0b66ea488b861cbafd4a896fbd931422}{INITIAL\+\_\+\+CHUNK\+\_\+\+SIZE}} = 4 $\ast$ 1024
\item 
static const int \mbox{\hyperlink{classdoris_1_1_mem_pool_ae966c6584335ae929dbd77531ebcf301}{MAX\+\_\+\+CHUNK\+\_\+\+SIZE}} = 512 $\ast$ 1024
\item 
static uint32\+\_\+t \mbox{\hyperlink{classdoris_1_1_mem_pool_ab6dd0f9c2f7f6a29a032ab185d4e700f}{k\+\_\+zero\+\_\+length\+\_\+region\+\_\+}} = \mbox{\hyperlink{mem__pool_8cpp_a0cc6ca3f6c7ecc98eac526d585f2ebba}{MEM\+\_\+\+POOL\+\_\+\+POISON}}
\end{DoxyCompactItemize}
\doxysubsection*{友元}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classdoris_1_1_mem_pool_a322861f486366e94b973dd022ab523a8}{Mem\+Pool\+Test}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
A \mbox{\hyperlink{classdoris_1_1_mem_pool}{Mem\+Pool}} maintains a list of memory chunks from which it allocates memory in response to Allocate() calls; Chunks stay around for the lifetime of the mempool or until they are passed on to another mempool. The caller registers a \mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}} with the pool; chunk allocations are counted against that tracker and all of its ancestors. If chunks get moved between pools during \mbox{\hyperlink{classdoris_1_1_mem_pool_a8390fe0aaec400317015c6c6f4c885b2}{acquire\+\_\+data()}} calls, the respective Mem\+Trackers are updated accordingly. Chunks freed up in the d\textquotesingle{}tor are subtracted from the registered trackers. An Allocate() call will attempt to allocate memory from the chunk that was most recently added; if that chunk doesn\textquotesingle{}t have enough memory to satisfy the allocation request, the free chunks are searched for one that is big enough otherwise a new chunk is added to the list. In order to keep allocation overhead low, chunk sizes double with each new one added, until they hit a maximum size.

Allocated chunks can be reused for new allocations if Clear() is called to free all allocations or Return\+Partial\+Allocation() is called to return part of the last allocation.

All chunks before \textquotesingle{}current\+\_\+chunk\+\_\+idx\+\_\+\textquotesingle{} have allocated memory, while all chunks after \textquotesingle{}current\+\_\+chunk\+\_\+idx\+\_\+\textquotesingle{} are free. The chunk at \textquotesingle{}current\+\_\+chunk\+\_\+idx\+\_\+\textquotesingle{} may or may not have allocated memory. \begin{DoxyVerb}Example:
MemPool* p = new MemPool();
for (int i = 0; i < 1024; ++i) {
\end{DoxyVerb}
 returns 8-\/byte aligned memory (effectively 24 bytes)\+: .. = p-\/\texorpdfstring{$>$}{>}Allocate(17); \} at this point, 17K have been handed out in response to Allocate() calls and 28K of chunks have been allocated (chunk sizes\+: 4K, 8K, 16K) We track total and peak allocated bytes. At this point they would be the same\+: 28k bytes. A call to Clear will return the allocated memory so total\+\_\+allocated\+\_\+bytes\+\_\+ becomes 0. p-\/\texorpdfstring{$>$}{>}Clear(); the entire 1st chunk is returned\+: .. = p-\/\texorpdfstring{$>$}{>}Allocate(4 $\ast$ 1024); 4K of the 2nd chunk are returned\+: .. = p-\/\texorpdfstring{$>$}{>}Allocate(4 $\ast$ 1024); a new 20K chunk is created .. = p-\/\texorpdfstring{$>$}{>}Allocate(20 $\ast$ 1024); Mem\+Pool$\ast$ p2 = new \mbox{\hyperlink{classdoris_1_1_mem_pool_a42145941c12bbb94e798490e14f940f4}{Mem\+Pool()}}; the new mempool receives all chunks containing data from p p2-\/\texorpdfstring{$>$}{>}acquire\+\_\+data(p, false); At this point p.\+total\+\_\+allocated\+\_\+bytes\+\_\+ would be 0. The one remaining (empty) chunk is released\+: delete p; 

\doxysubsection{构造及析构函数说明}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a8b3cced6f5cb7c5084768b29bb461a00}\label{classdoris_1_1_mem_pool_a8b3cced6f5cb7c5084768b29bb461a00}} 
\index{MemPool@{MemPool}!MemPool@{MemPool}}
\index{MemPool@{MemPool}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{MemPool()}{MemPool()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_mem_pool}{Mem\+Pool}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}} $\ast$}]{mem\+\_\+tracker }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a42145941c12bbb94e798490e14f940f4}\label{classdoris_1_1_mem_pool_a42145941c12bbb94e798490e14f940f4}} 
\index{MemPool@{MemPool}!MemPool@{MemPool}}
\index{MemPool@{MemPool}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{MemPool()}{MemPool()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_mem_pool}{Mem\+Pool}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a5d9436e563027071fb7f5471f26af32c}\label{classdoris_1_1_mem_pool_a5d9436e563027071fb7f5471f26af32c}} 
\index{MemPool@{MemPool}!````~MemPool@{$\sim$MemPool}}
\index{````~MemPool@{$\sim$MemPool}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{$\sim$MemPool()}{~MemPool()}}
{\footnotesize\ttfamily $\sim$\mbox{\hyperlink{classdoris_1_1_mem_pool}{Mem\+Pool}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Frees all chunks of memory and subtracts the total allocated bytes from the registered limits. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a5d9436e563027071fb7f5471f26af32c_cgraph}
\end{center}
\end{figure}


\doxysubsection{成员函数说明}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a6bbe6a57173c878bdb87ee90c87022a9}\label{classdoris_1_1_mem_pool_a6bbe6a57173c878bdb87ee90c87022a9}} 
\index{MemPool@{MemPool}!allocate@{allocate}}
\index{allocate@{allocate}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ allocate (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{bool}]{free\+\_\+old\+\_\+chunks = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocates a section of memory of \textquotesingle{}size\textquotesingle{} bytes with DEFAULT\+\_\+\+ALIGNMENT at the end of the current chunk. Creates a new chunk if there aren\textquotesingle{}t any chunks with enough capacity. 这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a6bbe6a57173c878bdb87ee90c87022a9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_ae6c8a9fd44a082f7172774fa2592c89b}\label{classdoris_1_1_mem_pool_ae6c8a9fd44a082f7172774fa2592c89b}} 
\index{MemPool@{MemPool}!allocate\_aligned@{allocate\_aligned}}
\index{allocate\_aligned@{allocate\_aligned}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{allocate\_aligned()}{allocate\_aligned()}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ allocate\+\_\+aligned (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{int}]{alignment }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{d7/d6b/classdoris_1_1_mem_pool_ae6c8a9fd44a082f7172774fa2592c89b_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_ae6c8a9fd44a082f7172774fa2592c89b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a09fa199573f5b5e14ccbf12b75d7dc1c}\label{classdoris_1_1_mem_pool_a09fa199573f5b5e14ccbf12b75d7dc1c}} 
\index{MemPool@{MemPool}!allocate\_safely@{allocate\_safely}}
\index{allocate\_safely@{allocate\_safely}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{allocate\_safely()}{allocate\_safely()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_status}{Status}} allocate\+\_\+safely (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{uint8\+\_\+t $\ast$\&}]{ret }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Same as Allocate() expect add a check when return a nullptr 

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a77c864da08b18a7f329ea3a4f03d3a49}\label{classdoris_1_1_mem_pool_a77c864da08b18a7f329ea3a4f03d3a49}} 
\index{MemPool@{MemPool}!try\_allocate@{try\_allocate}}
\index{try\_allocate@{try\_allocate}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{try\_allocate()}{try\_allocate()}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ try\+\_\+allocate (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Same as Allocate() except the mem limit is checked before the allocation and this call will fail (returns nullptr) if it does. The caller must handle the nullptr case. This should be used for allocations where the size can be very big to bound the amount by which we exceed mem limits. \mbox{\Hypertarget{classdoris_1_1_mem_pool_a593527fbb6f92934decc5c9971e6a6ed}\label{classdoris_1_1_mem_pool_a593527fbb6f92934decc5c9971e6a6ed}} 
\index{MemPool@{MemPool}!try\_allocate\_aligned@{try\_allocate\_aligned}}
\index{try\_allocate\_aligned@{try\_allocate\_aligned}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{try\_allocate\_aligned()}{try\_allocate\_aligned()}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ try\+\_\+allocate\+\_\+aligned (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{int}]{alignment }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Same as Try\+Allocate() except a non-\/default alignment can be specified. It should be a power-\/of-\/two in \mbox{[}1, alignof(std\+::max\+\_\+align\+\_\+t)\mbox{]}. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=347pt]{d7/d6b/classdoris_1_1_mem_pool_a593527fbb6f92934decc5c9971e6a6ed_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a6d26bcac68a4840a8aed98fe68998980}\label{classdoris_1_1_mem_pool_a6d26bcac68a4840a8aed98fe68998980}} 
\index{MemPool@{MemPool}!try\_allocate\_unaligned@{try\_allocate\_unaligned}}
\index{try\_allocate\_unaligned@{try\_allocate\_unaligned}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{try\_allocate\_unaligned()}{try\_allocate\_unaligned()}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ try\+\_\+allocate\+\_\+unaligned (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Same as Try\+Allocate() except returned memory is not aligned at all. 

\mbox{\Hypertarget{classdoris_1_1_mem_pool_ac8bb3912a3ce86b15842e79d0b421204}\label{classdoris_1_1_mem_pool_ac8bb3912a3ce86b15842e79d0b421204}} 
\index{MemPool@{MemPool}!clear@{clear}}
\index{clear@{clear}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily void clear (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Makes all allocated chunks available for re-\/use, but doesn\textquotesingle{}t delete any chunks. 

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=237pt]{d7/d6b/classdoris_1_1_mem_pool_ac8bb3912a3ce86b15842e79d0b421204_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=291pt]{d7/d6b/classdoris_1_1_mem_pool_ac8bb3912a3ce86b15842e79d0b421204_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_af4de2f83436cd4ed6744ced00335545a}\label{classdoris_1_1_mem_pool_af4de2f83436cd4ed6744ced00335545a}} 
\index{MemPool@{MemPool}!free\_all@{free\_all}}
\index{free\_all@{free\_all}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{free\_all()}{free\_all()}}
{\footnotesize\ttfamily void free\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Deletes all allocated chunks. \mbox{\hyperlink{classdoris_1_1_mem_pool_af4de2f83436cd4ed6744ced00335545a}{free\+\_\+all()}} or \mbox{\hyperlink{classdoris_1_1_mem_pool_a8390fe0aaec400317015c6c6f4c885b2}{acquire\+\_\+data()}} must be called for each mem pool 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_af4de2f83436cd4ed6744ced00335545a_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=322pt]{d7/d6b/classdoris_1_1_mem_pool_af4de2f83436cd4ed6744ced00335545a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a8390fe0aaec400317015c6c6f4c885b2}\label{classdoris_1_1_mem_pool_a8390fe0aaec400317015c6c6f4c885b2}} 
\index{MemPool@{MemPool}!acquire\_data@{acquire\_data}}
\index{acquire\_data@{acquire\_data}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{acquire\_data()}{acquire\_data()}}
{\footnotesize\ttfamily void acquire\+\_\+data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classdoris_1_1_mem_pool}{Mem\+Pool}} $\ast$}]{src,  }\item[{bool}]{keep\+\_\+current }\end{DoxyParamCaption})}

Absorb all chunks that hold data from src. If keep\+\_\+current is true, let src hold on to its last allocated chunk that contains data. All offsets handed out by calls to Get\+Current\+Offset() for \textquotesingle{}src\textquotesingle{} become invalid. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a8390fe0aaec400317015c6c6f4c885b2_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a4dcb28d0641b6d37aef23c662ec11908}\label{classdoris_1_1_mem_pool_a4dcb28d0641b6d37aef23c662ec11908}} 
\index{MemPool@{MemPool}!debug\_string@{debug\_string}}
\index{debug\_string@{debug\_string}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{debug\_string()}{debug\_string()}}
{\footnotesize\ttfamily std\+::string debug\+\_\+string (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_ac2c82d6ddaca81b4a1fbea56357a56a0}\label{classdoris_1_1_mem_pool_ac2c82d6ddaca81b4a1fbea56357a56a0}} 
\index{MemPool@{MemPool}!total\_allocated\_bytes@{total\_allocated\_bytes}}
\index{total\_allocated\_bytes@{total\_allocated\_bytes}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{total\_allocated\_bytes()}{total\_allocated\_bytes()}}
{\footnotesize\ttfamily int64\+\_\+t total\+\_\+allocated\+\_\+bytes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_ac2c82d6ddaca81b4a1fbea56357a56a0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_aa18c7f597cda80b68976807afee3ccae}\label{classdoris_1_1_mem_pool_aa18c7f597cda80b68976807afee3ccae}} 
\index{MemPool@{MemPool}!total\_reserved\_bytes@{total\_reserved\_bytes}}
\index{total\_reserved\_bytes@{total\_reserved\_bytes}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{total\_reserved\_bytes()}{total\_reserved\_bytes()}}
{\footnotesize\ttfamily int64\+\_\+t total\+\_\+reserved\+\_\+bytes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a3784f1d2cedbd86999122cf6b1419e81}\label{classdoris_1_1_mem_pool_a3784f1d2cedbd86999122cf6b1419e81}} 
\index{MemPool@{MemPool}!mem\_tracker@{mem\_tracker}}
\index{mem\_tracker@{mem\_tracker}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{mem\_tracker()}{mem\_tracker()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}} $\ast$ mem\+\_\+tracker (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a496b30429df7da46fc8fdc8cd6ffa680}\label{classdoris_1_1_mem_pool_a496b30429df7da46fc8fdc8cd6ffa680}} 
\index{MemPool@{MemPool}!find\_chunk@{find\_chunk}}
\index{find\_chunk@{find\_chunk}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{find\_chunk()}{find\_chunk()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_status}{Status}} find\+\_\+chunk (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{min\+\_\+size,  }\item[{bool}]{check\+\_\+limits,  }\item[{bool}]{free\+\_\+old\+\_\+chunks }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Find or allocated a chunk with at least min\+\_\+size spare capacity and update current\+\_\+chunk\+\_\+idx\+\_\+. Also updates chunks\+\_\+, chunk\+\_\+sizes\+\_\+ and allocated\+\_\+bytes\+\_\+ if a new chunk needs to be created. If check\+\_\+limits is true, this call can fail (returns false) if adding a new chunk exceeds the mem limits. 函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a496b30429df7da46fc8fdc8cd6ffa680_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=230pt]{d7/d6b/classdoris_1_1_mem_pool_a496b30429df7da46fc8fdc8cd6ffa680_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a6b20ce905b38d4fdd3d623e2d1fad9b2}\label{classdoris_1_1_mem_pool_a6b20ce905b38d4fdd3d623e2d1fad9b2}} 
\index{MemPool@{MemPool}!check\_integrity@{check\_integrity}}
\index{check\_integrity@{check\_integrity}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{check\_integrity()}{check\_integrity()}}
{\footnotesize\ttfamily bool check\+\_\+integrity (\begin{DoxyParamCaption}\item[{bool}]{check\+\_\+current\+\_\+chunk\+\_\+empty }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Check integrity of the supporting data structures; always returns true but DCHECKs all invariants. If \textquotesingle{}check\+\_\+current\+\_\+chunk\+\_\+empty\textquotesingle{} is true, checks that the current chunk contains no data. Otherwise the current chunk can be either empty or full. 这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a6b20ce905b38d4fdd3d623e2d1fad9b2_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a3c2ed43ca91dcc971913c2a307df6d77}\label{classdoris_1_1_mem_pool_a3c2ed43ca91dcc971913c2a307df6d77}} 
\index{MemPool@{MemPool}!get\_free\_offset@{get\_free\_offset}}
\index{get\_free\_offset@{get\_free\_offset}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{get\_free\_offset()}{get\_free\_offset()}}
{\footnotesize\ttfamily int64\+\_\+t get\+\_\+free\+\_\+offset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Return offset to unoccupied space in current chunk. 

这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=270pt]{d7/d6b/classdoris_1_1_mem_pool_a3c2ed43ca91dcc971913c2a307df6d77_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a55575a1816c844dbbaf0dba2cd0af4c0}\label{classdoris_1_1_mem_pool_a55575a1816c844dbbaf0dba2cd0af4c0}} 
\index{MemPool@{MemPool}!allocate\_from\_current\_chunk@{allocate\_from\_current\_chunk}}
\index{allocate\_from\_current\_chunk@{allocate\_from\_current\_chunk}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{allocate\_from\_current\_chunk()}{allocate\_from\_current\_chunk()}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ allocate\+\_\+from\+\_\+current\+\_\+chunk (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{int}]{alignment }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a55575a1816c844dbbaf0dba2cd0af4c0_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=276pt]{d7/d6b/classdoris_1_1_mem_pool_a55575a1816c844dbbaf0dba2cd0af4c0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_abcb9972328c7f8747a778c0969829d1a}\label{classdoris_1_1_mem_pool_abcb9972328c7f8747a778c0969829d1a}} 
\index{MemPool@{MemPool}!allocate@{allocate}}
\index{allocate@{allocate}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template uint8\+\_\+t $\ast$ allocate$<$ true $>$ (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{int}]{alignment,  }\item[{bool}]{free\+\_\+old\+\_\+chunks = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_abcb9972328c7f8747a778c0969829d1a_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a742414fe4ed173877a599b5b44c509c5}\label{classdoris_1_1_mem_pool_a742414fe4ed173877a599b5b44c509c5}} 
\index{MemPool@{MemPool}!allocate\_safely@{allocate\_safely}}
\index{allocate\_safely@{allocate\_safely}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{allocate\_safely()}{allocate\_safely()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_status}{Status}} \mbox{\hyperlink{compiler__util_8h_aa1dec568e79152c892dcf63f445cbd7a}{ALWAYS\+\_\+\+INLINE}} allocate\+\_\+safely (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{size,  }\item[{int}]{alignment,  }\item[{uint8\+\_\+t $\ast$\&}]{ret }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d7/d6b/classdoris_1_1_mem_pool_a742414fe4ed173877a599b5b44c509c5_cgraph}
\end{center}
\end{figure}


\doxysubsection{友元及相关函数文档}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a322861f486366e94b973dd022ab523a8}\label{classdoris_1_1_mem_pool_a322861f486366e94b973dd022ab523a8}} 
\index{MemPool@{MemPool}!MemPoolTest@{MemPoolTest}}
\index{MemPoolTest@{MemPoolTest}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{MemPoolTest}{MemPoolTest}}
{\footnotesize\ttfamily friend class Mem\+Pool\+Test\hspace{0.3cm}{\ttfamily [friend]}}



\doxysubsection{类成员变量说明}
\mbox{\Hypertarget{classdoris_1_1_mem_pool_a55e30d64539971321c58aa1a26d8b671}\label{classdoris_1_1_mem_pool_a55e30d64539971321c58aa1a26d8b671}} 
\index{MemPool@{MemPool}!DEFAULT\_ALIGNMENT@{DEFAULT\_ALIGNMENT}}
\index{DEFAULT\_ALIGNMENT@{DEFAULT\_ALIGNMENT}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{DEFAULT\_ALIGNMENT}{DEFAULT\_ALIGNMENT}}
{\footnotesize\ttfamily const int DEFAULT\+\_\+\+ALIGNMENT = 16\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a23ec6fd4aacd7be3f89a40feab9b4539}\label{classdoris_1_1_mem_pool_a23ec6fd4aacd7be3f89a40feab9b4539}} 
\index{MemPool@{MemPool}!DEFAULT\_PADDING\_SIZE@{DEFAULT\_PADDING\_SIZE}}
\index{DEFAULT\_PADDING\_SIZE@{DEFAULT\_PADDING\_SIZE}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{DEFAULT\_PADDING\_SIZE}{DEFAULT\_PADDING\_SIZE}}
{\footnotesize\ttfamily constexpr int DEFAULT\+\_\+\+PADDING\+\_\+\+SIZE = 0x0\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a0b66ea488b861cbafd4a896fbd931422}\label{classdoris_1_1_mem_pool_a0b66ea488b861cbafd4a896fbd931422}} 
\index{MemPool@{MemPool}!INITIAL\_CHUNK\_SIZE@{INITIAL\_CHUNK\_SIZE}}
\index{INITIAL\_CHUNK\_SIZE@{INITIAL\_CHUNK\_SIZE}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{INITIAL\_CHUNK\_SIZE}{INITIAL\_CHUNK\_SIZE}}
{\footnotesize\ttfamily const int INITIAL\+\_\+\+CHUNK\+\_\+\+SIZE = 4 $\ast$ 1024\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_ae966c6584335ae929dbd77531ebcf301}\label{classdoris_1_1_mem_pool_ae966c6584335ae929dbd77531ebcf301}} 
\index{MemPool@{MemPool}!MAX\_CHUNK\_SIZE@{MAX\_CHUNK\_SIZE}}
\index{MAX\_CHUNK\_SIZE@{MAX\_CHUNK\_SIZE}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{MAX\_CHUNK\_SIZE}{MAX\_CHUNK\_SIZE}}
{\footnotesize\ttfamily const int MAX\+\_\+\+CHUNK\+\_\+\+SIZE = 512 $\ast$ 1024\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

The maximum size of chunk that should be allocated. Allocations larger than this size will get their own individual chunk. \mbox{\Hypertarget{classdoris_1_1_mem_pool_ab6dd0f9c2f7f6a29a032ab185d4e700f}\label{classdoris_1_1_mem_pool_ab6dd0f9c2f7f6a29a032ab185d4e700f}} 
\index{MemPool@{MemPool}!k\_zero\_length\_region\_@{k\_zero\_length\_region\_}}
\index{k\_zero\_length\_region\_@{k\_zero\_length\_region\_}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{k\_zero\_length\_region\_}{k\_zero\_length\_region\_}}
{\footnotesize\ttfamily uint32\+\_\+t k\+\_\+zero\+\_\+length\+\_\+region\+\_\+ = \mbox{\hyperlink{mem__pool_8cpp_a0cc6ca3f6c7ecc98eac526d585f2ebba}{MEM\+\_\+\+POOL\+\_\+\+POISON}}\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

A static field used as non-\/nullptr pointer for zero length allocations. nullptr is reserved for allocation failures. It must be as aligned as max\+\_\+align\+\_\+t for Try\+Allocate\+Aligned(). \mbox{\Hypertarget{classdoris_1_1_mem_pool_aed7d68711317ab1df2c91ff520320321}\label{classdoris_1_1_mem_pool_aed7d68711317ab1df2c91ff520320321}} 
\index{MemPool@{MemPool}!current\_chunk\_idx\_@{current\_chunk\_idx\_}}
\index{current\_chunk\_idx\_@{current\_chunk\_idx\_}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{current\_chunk\_idx\_}{current\_chunk\_idx\_}}
{\footnotesize\ttfamily int current\+\_\+chunk\+\_\+idx\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

chunk from which we served the last Allocate() call; always points to the last chunk that contains allocated data; chunks 0..current\+\_\+chunk\+\_\+idx\+\_\+ -\/ 1 are guaranteed to contain data (chunks\+\_\+\mbox{[}i\mbox{]}.allocated\+\_\+bytes \texorpdfstring{$>$}{>} 0 for i\+: 0..current\+\_\+chunk\+\_\+idx\+\_\+ -\/ 1); chunks after \textquotesingle{}current\+\_\+chunk\+\_\+idx\+\_\+\textquotesingle{} are \char`\"{}free chunks\char`\"{} that contain no data. -\/1 if no chunks present \mbox{\Hypertarget{classdoris_1_1_mem_pool_a960c7e4aa89884aae5bc4ba96cc74167}\label{classdoris_1_1_mem_pool_a960c7e4aa89884aae5bc4ba96cc74167}} 
\index{MemPool@{MemPool}!next\_chunk\_size\_@{next\_chunk\_size\_}}
\index{next\_chunk\_size\_@{next\_chunk\_size\_}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{next\_chunk\_size\_}{next\_chunk\_size\_}}
{\footnotesize\ttfamily int next\+\_\+chunk\+\_\+size\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



The size of the next chunk to allocate. 

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a5999667e31d6e6cd3dfbae837e52d2f1}\label{classdoris_1_1_mem_pool_a5999667e31d6e6cd3dfbae837e52d2f1}} 
\index{MemPool@{MemPool}!total\_allocated\_bytes\_@{total\_allocated\_bytes\_}}
\index{total\_allocated\_bytes\_@{total\_allocated\_bytes\_}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{total\_allocated\_bytes\_}{total\_allocated\_bytes\_}}
{\footnotesize\ttfamily int64\+\_\+t total\+\_\+allocated\+\_\+bytes\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



sum of allocated\+\_\+bytes\+\_\+ 

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a8207c0d5e43fdd326d0064ea5f5a76d7}\label{classdoris_1_1_mem_pool_a8207c0d5e43fdd326d0064ea5f5a76d7}} 
\index{MemPool@{MemPool}!total\_reserved\_bytes\_@{total\_reserved\_bytes\_}}
\index{total\_reserved\_bytes\_@{total\_reserved\_bytes\_}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{total\_reserved\_bytes\_}{total\_reserved\_bytes\_}}
{\footnotesize\ttfamily int64\+\_\+t total\+\_\+reserved\+\_\+bytes\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



sum of all bytes allocated in chunks\+\_\+ 

\mbox{\Hypertarget{classdoris_1_1_mem_pool_a481f648c78e8f8ac2912c950c0f34e6c}\label{classdoris_1_1_mem_pool_a481f648c78e8f8ac2912c950c0f34e6c}} 
\index{MemPool@{MemPool}!chunks\_@{chunks\_}}
\index{chunks\_@{chunks\_}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{chunks\_}{chunks\_}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{structdoris_1_1_mem_pool_1_1_chunk_info}{Chunk\+Info}}$>$ chunks\+\_\+\hspace{0.3cm}{\ttfamily [private]}}

\mbox{\Hypertarget{classdoris_1_1_mem_pool_aeb56efb11f09c22f1a97a0238206da30}\label{classdoris_1_1_mem_pool_aeb56efb11f09c22f1a97a0238206da30}} 
\index{MemPool@{MemPool}!\_mem\_tracker@{\_mem\_tracker}}
\index{\_mem\_tracker@{\_mem\_tracker}!MemPool@{MemPool}}
\doxysubsubsection{\texorpdfstring{\_mem\_tracker}{\_mem\_tracker}}
{\footnotesize\ttfamily \mbox{\hyperlink{classdoris_1_1_mem_tracker}{Mem\+Tracker}}$\ast$ \+\_\+mem\+\_\+tracker\hspace{0.3cm}{\ttfamily [private]}}

The current and peak memory footprint of this pool. This is different from total allocated\+\_\+bytes\+\_\+ since it includes bytes in chunks that are not used. 

该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
/\+Users/dabowang/be\+\_\+all/runtime/\mbox{\hyperlink{mem__pool_8h}{mem\+\_\+pool.\+h}}\item 
/\+Users/dabowang/be\+\_\+all/runtime/\mbox{\hyperlink{mem__pool_8cpp}{mem\+\_\+pool.\+cpp}}\end{DoxyCompactItemize}
