<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ppl_util: /Users/dabowang/be_all/glibc-compatibility/memcpy/memcpy_x86_64.cpp 文件参考</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ppl_util
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_8eac97cde2fee0634bdd38dda0a21780.html">be_all</a></li><li class="navelem"><a class="el" href="../../dir_bb867f541a5076a92291517b265a7432.html">glibc-compatibility</a></li><li class="navelem"><a class="el" href="../../dir_a9cf2abec3b75a3b75ee4888a396f8d6.html">memcpy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">memcpy_x86_64.cpp 文件参考</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;emmintrin.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
memcpy_x86_64.cpp 的引用(Include)关系图:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../d4/d23/memcpy__x86__64_8cpp__incl.svg" width="215" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a11ebdd343428c466f2f35c376d7db6d0"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d07/memcpy__x86__64_8cpp.html#a11ebdd343428c466f2f35c376d7db6d0">inline_memcpy</a> (void *__restrict dst_, const void *__restrict src_, size_t size)</td></tr>
<tr class="separator:a11ebdd343428c466f2f35c376d7db6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156c5821f16ed93be8c7d315303f7b2a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d07/memcpy__x86__64_8cpp.html#a156c5821f16ed93be8c7d315303f7b2a">memcpy</a> (void *__restrict dst, const void *__restrict src, size_t size)</td></tr>
<tr class="separator:a156c5821f16ed93be8c7d315303f7b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">函数说明</h2>
<a id="a11ebdd343428c466f2f35c376d7db6d0" name="a11ebdd343428c466f2f35c376d7db6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ebdd343428c466f2f35c376d7db6d0">&#9670;&#160;</a></span>inline_memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * inline_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *__restrict&#160;</td>
          <td class="paramname"><em>dst_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *__restrict&#160;</td>
          <td class="paramname"><em>src_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom memcpy implementation for ClickHouse. It has the following benefits over using glibc's implementation:</p><ol type="1">
<li>Avoiding dependency on specific version of glibc's symbol, like memcpy@GLIBC_2.14 for portability.</li>
<li>Avoiding indirect call via PLT due to shared linking, that can be less efficient.</li>
<li>It's possible to include this header and call inline_memcpy directly for better inlining or interprocedural analysis.</li>
<li>Better results on our performance tests on current CPUs: up to 25% on some queries and up to 0.7%..1% in average across all queries.</li>
</ol>
<p>Writing our own memcpy is extremely difficult for the following reasons:</p><ol type="1">
<li>The optimal variant depends on the specific CPU model.</li>
<li>The optimal variant depends on the distribution of size arguments.</li>
<li>It depends on the number of threads copying data concurrently.</li>
<li>It also depends on how the calling code is using the copied data and how the different memcpy calls are related to each other. Due to vast range of scenarios it makes proper testing especially difficult. When writing our own memcpy there is a risk to overoptimize it on non-representative microbenchmarks while making real-world use cases actually worse.</li>
</ol>
<p>Most of the benchmarks for memcpy on the internet are wrong.</p>
<p>Let's look at the details:</p>
<p>For small size, the order of branches in code is important. There are variants with specific order of branches (like here or in glibc) or with jump table (in asm code see example from Cosmopolitan libc: <a href="https://github.com/jart/cosmopolitan/blob/de09bec215675e9b0beb722df89c6f794da74f3f/libc/nexgen32e/memcpy.S#L61">https://github.com/jart/cosmopolitan/blob/de09bec215675e9b0beb722df89c6f794da74f3f/libc/nexgen32e/memcpy.S#L61</a>) or with Duff device in C (see <a href="https://github.com/skywind3000/FastMemcpy/">https://github.com/skywind3000/FastMemcpy/</a>)</p>
<p>It's also important how to copy uneven sizes. Almost every implementation, including this, is using two overlapping movs.</p>
<p>It is important to disable -ftree-loop-distribute-patterns when compiling memcpy implementation, otherwise the compiler can replace internal loops to a call to memcpy that will lead to infinite recursion.</p>
<p>For larger sizes it's important to choose the instructions used:</p><ul>
<li>SSE or AVX or AVX-512;</li>
<li>rep movsb; Performance will depend on the size threshold, on the CPU model, on the "erms" flag ("Enhansed Rep MovS" - it indicates that performance of "rep movsb" is decent for large sizes) <a href="https://stackoverflow.com/questions/43343231/enhanced-rep-movsb-for-memcpy">https://stackoverflow.com/questions/43343231/enhanced-rep-movsb-for-memcpy</a></li>
</ul>
<p>Using AVX-512 can be bad due to throttling. Using AVX can be bad if most code is using SSE due to switching penalty (it also depends on the usage of "vzeroupper" instruction). But in some cases AVX gives a win.</p>
<p>It also depends on how many times the loop will be unrolled. We are unrolling the loop 8 times (by the number of available registers), but it not always the best.</p>
<p>It also depends on the usage of aligned or unaligned loads/stores. We are using unaligned loads and aligned stores.</p>
<p>It also depends on the usage of prefetch instructions. It makes sense on some Intel CPUs but can slow down performance on AMD. Setting up correct offset for prefetching is non-obvious.</p>
<p>Non-temporary (cache bypassing) stores can be used for very large sizes (more than a half of L3 cache). But the exact threshold is unclear - when doing memcpy from multiple threads the optimal threshold can be lower, because L3 cache is shared (and L2 cache is partially shared).</p>
<p>Very large size of memcpy typically indicates suboptimal (not cache friendly) algorithms in code or unrealistic scenarios, so we don't pay attention to using non-temporary stores.</p>
<p>On recent Intel CPUs, the presence of "erms" makes "rep movsb" the most benefitial, even comparing to non-temporary aligned unrolled stores even with the most wide registers.</p>
<p>memcpy can be written in asm, C or C++. The latter can also use inline asm. The asm implementation can be better to make sure that compiler won't make the code worse, to ensure the order of branches, the code layout, the usage of all required registers. But if it is located in separate translation unit, inlining will not be possible (inline asm can be used to overcome this limitation). Sometimes C or C++ code can be further optimized by compiler. For example, clang is capable replacing SSE intrinsics to AVX code if -mavx is used.</p>
<p>Please note that compiler can replace plain code to memcpy and vice versa.</p><ul>
<li>memcpy with compile-time known small size is replaced to simple instructions without a call to memcpy; it is controlled by -fbuiltin-memcpy and can be manually ensured by calling __builtin_memcpy. This is often used to implement unaligned load/store without undefined behaviour in C++.</li>
<li>a loop with copying bytes can be recognized and replaced by a call to memcpy; it is controlled by -ftree-loop-distribute-patterns.</li>
<li>also note that a loop with copying bytes can be unrolled, peeled and vectorized that will give you inline code somewhat similar to a decent implementation of memcpy.</li>
</ul>
<p>This description is up to date as of Mar 2021.</p>
<p>How to test the memcpy implementation for performance:</p><ol type="1">
<li>Test on real production workload.</li>
<li>For synthetic test, see utils/memcpy-bench, but make sure you will do the best to exhaust the wide range of scenarios.</li>
</ol>
<p>TODO: Add self-tuning memcpy with bayesian bandits algorithm for large sizes. See <a href="https://habr.com/en/company/yandex/blog/457612/">https://habr.com/en/company/yandex/blog/457612/</a> </p>
<p>We will use pointer arithmetic, so char pointer will be used. Note that __restrict makes sense (otherwise compiler will reload data from memory instead of using the value of registers due to possible aliasing).</p>
<p>Standard memcpy returns the original value of dst. It is rarely used but we have to do it. If you use memcpy with small but non-constant sizes, you can call inline_memcpy directly for inlining and removing this single instruction.</p>
<p>Small sizes and tails after the loop for large sizes. The order of branches is important but in fact the optimal order depends on the distribution of sizes in your application. This order of branches is from the disassembly of glibc's code. We copy chunks of possibly uneven size with two overlapping movs. Example: to copy 5 bytes [0, 1, 2, 3, 4] we will copy tail [1, 2, 3, 4] first and then head [0, 1, 2, 3].</p>
<p>Chunks of 8..16 bytes.</p>
<p>Chunks of 4..7 bytes.</p>
<p>Chunks of 2..3 bytes.</p>
<p>A single byte.</p>
<p>No bytes remaining.</p>
<p>Medium and large sizes.</p>
<p>Medium size, not enough for full loop unrolling.</p>
<p>We will copy the last 16 bytes.</p>
<p>Then we will copy every 16 bytes from the beginning in a loop. The last loop iteration will possibly overwrite some part of already copied last 16 bytes. This is Ok, similar to the code for small sizes above.</p>
<p>Large size with fully unrolled loop.</p>
<p>Align destination to 16 bytes boundary.</p>
<p>If not aligned - we will copy first 16 bytes with unaligned stores.</p>
<p>Aligned unrolled copy. We will use half of available SSE registers. It's not possible to have both src and dst aligned. So, we will use aligned stores and unaligned loads.</p>
<p>The latest remaining 0..127 bytes will be processed as usual.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../df/d07/memcpy__x86__64_8cpp_a11ebdd343428c466f2f35c376d7db6d0_icgraph.svg" width="240" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a156c5821f16ed93be8c7d315303f7b2a" name="a156c5821f16ed93be8c7d315303f7b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156c5821f16ed93be8c7d315303f7b2a">&#9670;&#160;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * memcpy </td>
          <td>(</td>
          <td class="paramtype">void *__restrict&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *__restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../df/d07/memcpy__x86__64_8cpp_a156c5821f16ed93be8c7d315303f7b2a_cgraph.svg" width="240" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
